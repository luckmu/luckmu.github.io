<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.109.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>TIME_WAIT in TCP &#183; Luckmu's writepad</title><meta name=description content><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://luckmu.github.io/><h1>Luckmu's writepad</h1></a><p class=lead>Luckmu's daily writings.</p></div><nav><ul class=sidebar-nav><li><a href=https://luckmu.github.io/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/categories/>Categories</a></li></ul></nav><p>&copy; 2023. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>TIME_WAIT in TCP</h1><time datetime=2023-01-03T04:41:57+0800 class=post-date>Tue, Jan 3, 2023</time><p>之前 k8s 集群里出现过多 <code>TIME_WAIT</code> 导致网络问题, 又面试遇到, 特记录。</p><p>主要问题是:</p><ol><li><code>TIME_WAIT</code> 的定义?</li><li>为什么需要 <code>TIME_WAIT</code> 且持续 <code>2*MSL</code>?</li><li><code>TIME_WAIT</code> 引起的问题? 怎么解决?</li></ol><h2 id=what-is-time_wait>What is <code>TIME_WAIT</code>?</h2><p><code>TIME_WAIT</code> 是 TCP 的 1 个状态;</p><p>即在 4 次挥手过程中, 主动断开连接方收到被动方 <code>FIN</code> 后, 随即发送 <code>ACK</code>; 此时(发送 <code>ACK</code> 后)进入 <code>TIME_WAIT</code> 状态，并在等待 <code>2*MSL</code> 时间后变为 <code>CLOSED</code> 状态并断开连接</p><p><strong>MSL(Maximum Segment Lifetime)</strong>: 报文最大生存时间; 如果报文在网络中活动 MSL 后没被接收方收到, 随即丢弃;</p><p><em>RFC 793 建议为 2 min, 但取决于实现, Linux 为 30s, 即 <code>2*MSL</code> 为 60s, 硬编码于内核(<del>除非重新编译内核, 无法修改此值</del>)</em></p><h2 id=why-2msl>Why <code>2*MSL</code>?</h2><p><strong>将无 <code>TIME_WAIT</code> (<code>TIME_WAIT</code>=0) 阶段视为 <code>TIME_WAIT</code> &lt; <code>2*MSL</code>;</strong></p><p><code>TIME_WAIT</code> 短于 <code>2*MSL</code>, 客户端可以正常关闭连接, 而服务端则有两种情况:</p><ul><li>没有收到客户端 <code>ACK</code>, 进行 <code>FIN</code> 重传<ul><li><code>TIME_WAIT</code> &lt; <code>2*MSL</code>, 此时服务端没有收到 <code>ACK</code>, 开始重传 <code>FIN</code>, 而客户端已经 <code>CLOSED</code>;<br>则服务端无法正常关闭 (收不到 <code>ACK</code>); 若此时客户端以相同的 4 元组 (src_ip, src_port, dst_ip, dst_port) 请求新的 TCP 连接, 会被服务端返回 RST 包并拒绝连接请求;</li></ul></li><li>收到 <code>ACK</code>, 并关闭连接<ul><li><code>TIME_WAIT</code> &lt; <code>2*MSL</code>, 如果客户端以相同 4 元组建立新的 TCP 连接;<br>但网络中仍有旧连接的数据 (<u>e.g. 客户端在发送最后的 <code>ACK</code> 之前, 发送的包到达服务端 &lt;<code>1*MSL</code>, 服务端应答并到达客户端 &lt;<code>1*MSL</code></u>), 这个旧的包可能刚好可以被客户端承认</li></ul></li></ul><h2 id=too-many-time_waits>Too many <code>TIME_WAIT</code>s</h2><p><code>net.ipv4.tcp_tw_reuse</code>: 新的 timestamp 如果严格大于之前连接记录的最近的 timestamp, 1 个处于 <code>TIME_WAIT</code> 的 outgoing 连接可以被重用 (等待 1s 即可)。</p><ul><li>客户端 <code>ACK</code> 丢包, 服务端处于 <code>LAST_ACK</code> 状态;</li><li>客户端准备建立连接, 发送 <code>SYN</code> 包;</li><li>服务端收到 <code>SYN</code> 包, 返回 <code>FIN, ACK</code> 而不是 <code>RST</code> 重置连接;</li><li>客户端收到 <code>FIN, ACK</code>, 发送 <code>RST</code> 重置连接;</li><li>客户端发送 <code>SYN</code> 建立连接;</li></ul><h2 id=refer>Refer:</h2><ul><li><a href=https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux>Coping with the TCP TIME-WAIT state on busy Linux servers</a></li><li><a href=https://huoding.com/2013/12/31/316>再叙 TIME_WAIT</a></li><li><a href=https://draveness.me/whys-the-design-tcp-time-wait/>为什么 TCP 协议有 TIME_WAIT 状态</a></li></ul></div></main></body></html>