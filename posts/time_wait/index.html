<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>`TIME_WAIT` in TCP</title><link rel=stylesheet href=/css/style.css></head><body><header><a href=https://luckmu.github.io/>luckmu's writepad</a><nav><ul><li><a href=/tags/>Tags</a></li><li><a href=/categories/>Categories</a></li></ul></nav></header><main><article><h1>`TIME_WAIT` in TCP</h1><time datetime="Tuesday, January 3, 2023">Tuesday, January 3, 2023</time><div><p>什么是 <code>TIME_WAIT</code>? 为什么需要 <code>TIME_WAIT</code>? 为什么 <code>TIME_WAIT</code> 长 <code>2*MSL</code>?</p><h2 id=what-is-time_wait>What is <code>TIME_WAIT</code>?</h2><p><code>TIME_WAIT</code> 是 TCP 的 1 个状态;</p><p>即在 4 次挥手过程中, 主动断开连接方收到被动方 FIN 后, 随即发送 ACK; 此时(发送 ACK 后)进入 <code>TIME_WAIT</code> 状态，并在等待 <code>2MSL</code> 时间后变为 <code>CLOSED</code> 状态并断开连接</p><p><strong>MSL(Maximum Segment Lifetime)</strong>: 报文最大生存时间; 如果报文在网络中活动 MSL 后没被接收方收到, 随即丢弃;</p><p> <em>&ldquo;RFC 793 建议为 2 min, 但取决于实现, Linux 为 30s, 即 2MSL 为 60s, 硬编码于内核(<del>除非重新编译内核, 无法修改此值</del>)&rdquo;</em></p><h2 id=why-time_wait-why-2msl>Why <code>TIME_WAIT</code>? Why <code>2MSL</code>?</h2><p><strong>将没有 TIME_WAIT (TIME_WAIT=0) 阶段视为 TIME_WAIT &lt; 2MSL;</strong></p><p>TIME_WAIT 短于 2MSL, 客户端可以正常关闭连接, 而服务端则有两种情况:</p><ul><li>没有收到客户端 ACK, 进行 FIN 重传<ul><li><code>TIME_WAIT</code> &lt; <code>2MSL</code>, 此时服务端没有收到 ACK, 开始重传 FIN, 而客户端已经 <code>CLOSED</code>;<br>则服务端无法正常关闭 (收不到 ACK); 若此时客户端以相同的 4 元组 (src_ip, src_port, dst_ip, dst_port) 请求新的 TCP 连接, 会被服务端返回 RST 包并拒绝连接请求;</li></ul></li><li>收到 ACK, 并关闭连接<ul><li><code>TIME_WAIT</code> &lt; <code>2MSL</code>, 如果客户端以相同 4 元组建立新的 TCP 连接;<br>但网络中仍有旧连接的数据 (<u>e.g. 客户端在发送最后的 ACK 之前, 发送的包到达服务端 &lt;1MSL, 服务端应答并到达客户端 &lt;1MSL</u>), 这个旧的包可能刚好可以被客户端承认</li></ul></li></ul></div><div><ul id=tags><li><a href=/tags/tcp>tcp</a></li></ul></div></article></main><footer><p>&copy; 2023 <a href=https://luckmu.github.io/>luckmu's writepad</a></p></footer></body></html>