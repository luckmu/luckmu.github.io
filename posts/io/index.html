<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.109.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Five Network I/O Models &#183; Luckmu's writepad</title><meta name=description content><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://luckmu.github.io/><h1>Luckmu's writepad</h1></a><p class=lead>Luckmu's daily writings.</p></div><nav><ul class=sidebar-nav><li><a href=https://luckmu.github.io/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/categories/>Categories</a></li></ul></nav><p>&copy; 2023. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Five Network I/O Models</h1><time datetime=2023-01-04T17:27:49+0800 class=post-date>Wed, Jan 4, 2023</time><p>5 network I/O models: blocking, nonblocking, multiplexing, signal-driven, asynchronous</p><h2 id=blocking-io-model>Blocking I/O Model</h2><p><img src=/posts/io-1.png alt=blocking></p><p>如果 no datagram ready, 系统阻塞 (blocking) 直到 datagram ready, 然后 copy datagarm</p><h2 id=nonblocking-io-model>Nonblocking I/O Model</h2><p><img src=/posts/io-2.png alt=nonblocking></p><p><strong>loop polling</strong>:<br><strong>if</strong> no datagram ready: 立即返回 err (EWOULDBLOCK)<br><strong>else if</strong> datagram ready: 进行 recvfrom I/O, copy datagram 并返回 (blocking)</p><p>整个流程不阻塞 application</p><h2 id=io-multiplexing-model>I/O Multiplexing Model</h2><p><img src=/posts/io-3.png alt=multiplexing></p><p>可见, select 和 blocking 流程是相似的, 甚至于 select 需要 2 个 system call, 那么 select 是否不如 blocking 呢?</p><p>答案为<strong>否</strong>;</p><ul><li><u>select 可以同时等待多个 <strong>fd</strong> to be ready;</u><ul><li>ready 后 recvfrom I/O, copy data 并返回 (blocking)</li></ul></li><li>如 blocking 要达到相似的效果, 需要多个线程等待多个 <strong>fd</strong> (每个 thread 都调用 recvfrom 进行 1 个 blocking I/O);</li></ul><h2 id=signal-driven-io-model>Signal-Driven I/O Model</h2><p><img src=/posts/io-4.png alt=signal-driven></p><p>系统调用 (system call) <strong>sigaction</strong> 得到 signal handler,</p><p>datagram ready, handler 收到 <strong>SIGIO</strong>, recvfrom 并 copy datagram 到用户空间 (blocking)</p><h2 id=asynchronous-io-model>Asynchronous I/O Model</h2><p><img src=/posts/io-5.png alt=asynchronous></p><p>aio_read; 直到 datagram copy 完成 (data 复制到应用 buffer) 才返回, 也是和 signal-driven 的区别, 纯异步 (其他方法 recvfrom 是同步的, 即真实 I/O op 是同步的)</p><h2 id=refer>Refer:</h2><ul><li><a href=https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html>5 Network I/O Models</a></li></ul></div></main></body></html>