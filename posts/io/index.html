<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Five Network I/O Models</title><link rel=stylesheet href=/css/style.css></head><body><header><a href=https://luckmu.github.io/>Luckmu's writepad</a><nav><ul><li><a href=/tags/>Tags</a></li><li><a href=/categories/>Categories</a></li></ul></nav></header><main><article><h1>Five Network I/O Models</h1><div><p>Tags:
<a href=/tags/io>Io</a></p><p>Date: <time datetime="Wednesday, January 4, 2023">Wednesday, January 4, 2023</time></p></div><div><p>5 network I/O models: blocking, nonblocking, multiplexing, signal-driven, asynchronous</p><h2 id=blocking-io-model>Blocking I/O Model</h2><p><img src=/posts/io-1.png alt=blocking></p><p>如果 no datagram ready, 系统阻塞 (blocking) 直到 datagram ready, 然后 copy datagarm</p><h2 id=nonblocking-io-model>Nonblocking I/O Model</h2><p><img src=/posts/io-2.png alt=nonblocking></p><p><strong>loop polling</strong>:<br><strong>if</strong> no datagram ready: 立即返回 err (EWOULDBLOCK)<br><strong>else if</strong> datagram ready: 进行 recvfrom I/O, copy datagram 并返回 (blocking)</p><p>整个流程不阻塞 application</p><h2 id=io-multiplexing-model>I/O Multiplexing Model</h2><p><img src=/posts/io-3.png alt=multiplexing></p><p>可见, select 和 blocking 流程是相似的, 甚至于 select 需要 2 个 system call, 那么 select 是否不如 blocking 呢?</p><p>答案为<strong>否</strong>;</p><ul><li><u>select 可以同时等待多个 <strong>fd</strong> to be ready;</u><ul><li>ready 后 recvfrom I/O, copy data 并返回 (blocking)</li></ul></li><li>如 blocking 要达到相似的效果, 需要多个线程等待多个 <strong>fd</strong> (每个 thread 都调用 recvfrom 进行 1 个 blocking I/O);</li></ul><h2 id=signal-driven-io-model>Signal-Driven I/O Model</h2><p><img src=/posts/io-4.png alt=signal-driven></p><p>系统调用 (system call) <strong>sigaction</strong> 得到 signal handler,</p><p>datagram ready, handler 收到 <strong>SIGIO</strong>, recvfrom 并 copy datagram 到用户空间 (blocking)</p><h2 id=asynchronous-io-model>Asynchronous I/O Model</h2><p><img src=/posts/io-5.png alt=asynchronous></p><p>aio_read; 直到 datagram copy 完成 (data 复制到应用 buffer) 才返回, 也是和 signal-driven 的区别, 纯异步 (其他方法 recvfrom 是同步的, 即真实 I/O op 是同步的)</p><h2 id=refer>Refer:</h2><ul><li><a href=https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html>5 Network I/O Models</a></li></ul></div></article></main><footer><p>&copy; 2023 <a href=https://luckmu.github.io/>Luckmu</a></p></footer></body></html>