<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Kernel-User Mode</title><link rel=stylesheet href=/css/style.css></head><body><header><a href=https://luckmu.github.io/>Luckmu's writepad</a><nav><ul><li><a href=/tags/>Tags</a></li><li><a href=/categories/>Categories</a></li></ul></nav></header><main><article><h1>Kernel-User Mode</h1><div><p>Tags:
<a href=/tags/linux>Linux</a></p><p>Date: <time datetime="Friday, January 6, 2023">Friday, January 6, 2023</time></p></div><div><p>用户态和内核态是什么? 为什么要做这种区分? 如何实现?</p><p>What: <u>限制应用 (application) 可执行的指令 (instructions) 以及可以访问的地址空间;</u></p><p>Why: <u>避免用户进程导致系统崩溃; 取而代之, 应用崩溃只导致进程崩溃;</u></p><blockquote><p><strong>Crashing &ldquo;application&rdquo; might crash the entire system -> Crashing &ldquo;application&rdquo; only crash the process;</strong></p></blockquote><p>How: <u>表征进程的特权状态, 通过 mode bit 实现区分;</u></p><ul><li>x86 CPU 提供了 4 <a href=https://en.wikipedia.org/wiki/Protection_ring>protection rings</a>, 对应着执行指令的特权级别: 0, 1, 2 and 3; Linux 只用了 0 (kernel-mode) 和 3 (user-mode);</li><li>控制寄存器中的模式位 (mode bit) 标识当前进程处于什么特权级别 (kernel or user mode);<ul><li>mode bit set -> <strong>kernel mode</strong>: <u>可以执行任何指令, 访问任何内存地址;</u></li><li>mode bit not set -> <strong>user mode</strong>: <u>不允许执行特权指令 (halt the processor, change the mode bit, initiate I/O operation), 不允许直接引用代码空间中内核区域的代码和数据;</u></li></ul></li></ul><p>To kernel mode: 通过 exception (<strong>interrupt</strong>, <strong>fault</strong>, <strong>trapping system call</strong>), 并传递给 exception handler, handler 在 kernel mode 运行;</p><h2 id=refer>Refer</h2><ul><li>csapp 8.2.4</li><li><a href=https://blog.codinghorror.com/understanding-user-and-kernel-mode/>Understanding User and Kernel Mode</a></li><li><a href=https://segmentfault.com/a/1190000039774784>从根上理解用户态与内核态</a></li></ul></div></article></main><footer><p>&copy; 2023 <a href=https://luckmu.github.io/>Luckmu</a></p></footer></body></html>