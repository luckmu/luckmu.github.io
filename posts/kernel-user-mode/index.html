<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Kernel-User Mode &#183; Luckmu's writepad</title><meta name=description content><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://luckmu.github.io/><h1>Luckmu's writepad</h1></a><p class=lead>Luckmu's daily writings.</p></div><nav><ul class=sidebar-nav><li><a href=https://luckmu.github.io/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/categories/>Categories</a></li></ul></nav><p>&copy; 2023. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Kernel-User Mode</h1><time datetime=2023-01-06T16:51:43+0800 class=post-date>Fri, Jan 6, 2023</time><p>用户态和内核态是什么? 为什么要做这种区分? 如何实现?</p><p>What: <u>限制应用 (application) 可执行的指令 (instructions) 以及可以访问的地址空间;</u></p><p>Why: <u>避免用户进程导致系统崩溃; 取而代之, 应用崩溃只导致进程崩溃;</u></p><blockquote><p><strong>Crashing &ldquo;application&rdquo; might crash the entire system -> Crashing &ldquo;application&rdquo; only crash the process;</strong></p></blockquote><p>How: <u>表征进程的特权状态, 通过 mode bit 实现区分;</u></p><ul><li>x86 CPU 提供了 4 <a href=https://en.wikipedia.org/wiki/Protection_ring>protection rings</a>, 对应着执行指令的特权级别: 0, 1, 2 and 3; Linux 只用了 0 (kernel-mode) 和 3 (user-mode);</li><li>控制寄存器中的模式位 (mode bit) 标识当前进程处于什么特权级别 (kernel or user mode);<ul><li>mode bit set -> <strong>kernel mode</strong>: <u>可以执行任何指令, 访问任何内存地址;</u></li><li>mode bit not set -> <strong>user mode</strong>: <u>不允许执行特权指令 (halt the processor, change the mode bit, initiate I/O operation), 不允许直接引用代码空间中内核区域的代码和数据;</u></li></ul></li></ul><p>To kernel mode: 通过 exception (<strong>interrupt</strong>, <strong>fault</strong>, <strong>trapping system call</strong>), 并传递给 exception handler, handler 在 kernel mode 运行;</p><h2 id=refer>Refer</h2><ul><li>csapp 8.2.4</li><li><a href=https://blog.codinghorror.com/understanding-user-and-kernel-mode/>Understanding User and Kernel Mode</a></li><li><a href=https://segmentfault.com/a/1190000039774784>从根上理解用户态与内核态</a></li></ul></div></main></body></html>