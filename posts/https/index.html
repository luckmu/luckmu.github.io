<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>About HTTPS &#183; Luckmu's writepad</title><meta name=description content><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://luckmu.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://luckmu.github.io/><h1>Luckmu's writepad</h1></a><p class=lead>Luckmu's daily writings.</p></div><nav><ul class=sidebar-nav><li><a href=https://luckmu.github.io/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/categories/>Categories</a></li></ul></nav><p>&copy; 2023. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>About HTTPS</h1><time datetime=2023-01-02T23:47:46+0800 class=post-date>Mon, Jan 2, 2023</time><p>主要是 https 的原理和流程, 以及基础的 faq 。</p><h2 id=asymmetric-encryption>Asymmetric encryption</h2><p>欧拉定理, 使得取模运算有某种程度的可逆性; 即 <code>x^(p*q) mod N = y;</code>, 有:</p><ul><li><code>x^p mod N = y;</code></li><li><code>y^q mod N = x;</code></li></ul><p>可以理解为: <code>x</code> 用 <code>p</code> 加密得 <code>y</code>; <code>y</code> 用 <code>q</code> 解密得 <code>x</code>; <del>即 <code>p</code> 是公钥, <code>q</code> 是私钥;</del></p><p>有 <code>f(x, p) -> y;</code> 或 <code>f(y, q) -> x;</code> 是易求得的;</p><p>而如果 <code>N</code> 巨大, 未知 <code>p</code>、<code>q</code> 的情况; 以现有算力互推 <code>x</code>、<code>y</code>, 在较长时间可以认为无法实现 (只能遍历幂值, 直到等式成立)</p><p><code>p</code>, <code>q</code> 就是非对称加密的 1 对密钥; 且公钥、私钥都能用于加密 (<em>公钥加密: 加密; 私钥加密: 签名</em>)</p><h2 id=https>HTTPS</h2><p><code>HTTPS = HTTP + SSL/TLS</code>; <code>HTTPS Handshake = TCP 3WH + TLS 4WH</code></p><p>TLS 4WH:</p><ul><li>1WH: <code>ClientHello</code>, 发送 <code>client_random</code>, 支持的 TLS 版本, 支持的加密套件</li><li>2WH: <code>ServerHello</code>, 发送 <code>server_random</code>, 选定的 TLS 版本, 选定的加密套件</li><li>3WH:<ul><li><code>ClientKeyExchange</code>: 生成 <code>pre_master_key (预主密钥)</code>, 从服务器证书取出服务器公钥, 用服务器公钥加密 <code>pre_master_key</code> 发送给服务端</li><li><code>ChangeCipherSpec</code>: 用 <code>client_random</code>, <code>server_random</code>, <code>per_master_key</code> 计算得 <code>key_block (会话密钥)</code></li><li><code>EncryptedHandshakeMessage</code>: 握手信息生成摘要(hash), 用 <code>key_block</code> 加密给服务端校验, 至此客户端握手结束, 称 <code>Finished</code> 报文</li></ul></li><li>4WH:<ul><li><code>ChangeCipherSpec</code>: 用服务器私钥解密得到 <code>per_mater_key</code>, 并通过 <code>client_random</code>, <code>server_random</code>, <code>per_master_key</code> 计算得 <code>key_block</code></li><li><code>EncryptedHandshakeMessage</code>: 握手信息生成摘要, 用 <code>key_block</code> 加密给客户端校验, 至此服务端握手结束, 称 <code>Finished</code> 报文</li></ul></li></ul><h2 id=faq>FAQ</h2><ul><li><strong>HTTPS 是对称加密还是非对称加密?</strong><ul><li>既用到了非对称加密也用到了对称加密<ul><li>4 次握手, 用<strong>非对称加密</strong>交换 3 个随机数</li><li>加密通信, 用<strong>会话密钥</strong>进行<strong>对称加密</strong>通信</li></ul></li></ul></li><li><strong>为什么不都用非对称加密?</strong><ul><li>相对来说, 对称加密比非对称加密更快<ul><li>对称加密主要是位运算, 速度非常快</li><li>非对称加密计算1般比较复杂, 涉及大数乘法、大数模等运算</li></ul></li></ul></li><li><strong>服务器证书是什么? 怎么从里面取出公钥?</strong><ul><li>服务器证书, 本质上是 CA 的私钥加密过的服务器公钥<ul><li>服务器公钥 + CA 私钥 -> 服务器证书</li><li>服务器证书 + CA 公钥 -> 服务器公钥</li></ul></li></ul></li><li><strong>为什么不直接传公钥? 而要以服务器证书的方式加密传输?</strong><ul><li>若只传公钥, 在传输过程中公钥可能被黑客替换, 如果客户端用假公钥加密 <code>pre_master_key</code> 并返回, 黑客解密后得到 <code>pre_master_key</code>, 又 <code>client_random</code>, <code>server_random</code> 是明文传输, 黑客可以计算出<strong>会话密钥</strong></li><li>所以 CA 私钥加密得服务器证书就是为了保证客户端得到真正的服务器公钥</li></ul></li><li><strong>怎么获取CA公钥?</strong><ul><li>请求 CA 官网? 服务器压力太大, 能颁发证书的CA机构并不多, 因此对应CA公钥也不多, 作为配置直接放到操作系统或浏览器中</li></ul></li><li><strong>3 个随机数的安全性?</strong><ul><li>Client Random 和 Server Random 都是明文的, 可以获取, 但 pre_master_key 通过服务器公钥加密, 只有服务器私钥能解密, 被别人获取了也无法得到原文</li></ul></li><li><strong>为什么用 3 个随机数?</strong><ul><li>其实即使没有 Client Random 和 Server Random 也不影响加密功能, 单个 pre_master_key 随机性不足, 多次随机可能得到密钥是相同的, 再引入 2 个随机数, 大大增加<strong>会话密钥</strong>的随机性, 保证每次 HTTPS 通信用的会话密钥都是不同的</li></ul></li><li><strong>为什么 3、4 次握手要传摘要?</strong><ul><li>对大段文本进行 hash 操作, 确认通信过程中数据没有被篡改过<ul><li>第 3 次握手, 客户端生成摘要, 服务器验证, 如果验证通过, 客户端是可信的</li><li>第 4 次握手, 服务端生成摘要, 客户端验证, 如果验证通过, 服务端是可信的</li></ul></li></ul></li><li><strong>为什么要 hash 摘要而不是原文摘要?</strong><ul><li>hash 让数据变短, 更小的传输成本</li></ul></li><li><strong>整个过程涉及了几对私钥、公钥?</strong><ul><li>2 对:<ul><li>服务器公钥、私钥: 公钥(在数字证书中), 客户端用于加密 3 个随机数得<strong>会话密钥</strong>, 服务端用对应私钥解密</li><li>CA 公钥、私钥: 二次握手, 服务器数字证书是用CA私钥加密, 客户端用CA公钥解密得到服务器公钥</li></ul></li></ul></li></ul><h2 id=refer>Refer</h2><ul><li><a href=https://mp.weixin.qq.com/s/YXVURw55G2hT7BtShdGG4A>为什么用公钥加密却不能用公钥解密?</a></li><li><a href=https://halfrost.com/https-key-cipher/>TLS 中的密钥计算</a></li><li><a href=https://cloud.tencent.com/developer/article/1672173>为什么非对称加密比对称加密慢?</a></li></ul></div></main></body></html>